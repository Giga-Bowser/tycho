factorial := func(n: number) -> number {
	if n == 0 {
		return 1
	}

	return n * factorial(n - 1)
}

countSpaces := func(str: string) -> number {
	count := 0
	for i in 1..#str {
		if str[i] == " " {
			count = count + 1
		}
	}
	return count
}

lerp := func(a: number, b:number, t:number) -> number {
	return (1 - t) * a + t * b
}

sign := func(n: number) -> number {
	val := 0
	if n > 0 {
		val = 1
	} else if n < 0 {
		val = -1
	}

	return val
}

clamp := func(value: number, min: number, max: number) -> number {
	return math.min(math.max(value, min), max)
}

clampMag := func(value: number, min: number, max: number) -> number {
	return sign(value) * clamp(math.abs(value), math.abs(min), math.abs(max))
}

while_break_example := func() {
	i := 0
	while i < 10 {
		n := math.random(20)
		if n > 15 {
			break
		}
		i = i + 1
	}
}

getTrapezoidSpeed := func(
	startSpeed: number,
	middleSpeed: number,
	endSpeed: number,
	totalDistance: number,
	rampUpDistance: number,
	rampDownDistance: number,
	currentDistance: number
) -> number {
	// if the ramp up/down distances are too great, simply lerp from start to finish instead of ramping
	if rampDownDistance + rampUpDistance > totalDistance {
		if currentDistance < 0 {
			return startSpeed
		} else if totalDistance < currentDistance {
			return endSpeed
		}

		return lerp(startSpeed, endSpeed, currentDistance / totalDistance)
	}

	if currentDistance < 0 {
		return startSpeed
	} else if currentDistance < rampUpDistance {
		return lerp(startSpeed, middleSpeed, currentDistance / rampUpDistance)
	} else if currentDistance < totalDistance - rampDownDistance {
		return middleSpeed
	} else if currentDistance < totalDistance {
		rampDownStartDistance := (totalDistance - rampDownDistance)
		return lerp(middleSpeed, endSpeed, (currentDistance - rampDownStartDistance) / rampDownDistance)
	} else {
		return endSpeed
	}
}

bezier := func(t: number, p1: number, p2: number, p3: number, p4: number) -> number {
	q1 := lerp(p1, p2, t)
	q2 := lerp(p2, p3, t)
	q3 := lerp(p3, p4, t)

	r1 := lerp(q1, q2, t)
	r2 := lerp(q2, q3, t)

	return lerp(r1, r2, t)
}

doGrossRampStuff := func(curr: number, targ: number, accel: number, decel: number) -> number {
	if curr == 0 || (curr > 0 && targ > curr) || (curr < 0 && targ < curr) {
		// accelerating
		change := math.min(math.abs(curr - targ), accel) * sign(targ - curr)
		curr = curr + change
	} else if (curr > 0 && targ < curr) || (curr < 0 && targ > curr) {
		// decelerating
		change := math.min(math.abs(curr - targ), decel) * sign(targ - curr)
		curr = curr + change
	}

	return curr
}

deadband := func(value: number, band: number) -> number {
	if value > band {
		return (value - band) / (1 - band)
	} else if value < -band {
		return (value + band) / (1 - band)
	}

	return 0
}

struct Vector {
	x: number,
	y: number

	constructor(x: number, y: number) {
		self.x = x
		self.y = y
	}
}

Vector:length := func() -> number {
	return math.sqrt(self.x * self.x + self.y * self.y)
}

Vector:normalized := func() -> Vector {
	return Vector:new(self.x / self:length(), self.y / self:length())
}

Vector:rotate := func(radAng: number) -> Vector {
	return Vector:new(
		(self.x * math.cos(radAng)) - (self.y * math.sin(radAng)),
		(self.x * math.sin(radAng)) + (self.y * math.cos(radAng))
	)
}

Vector:dot := func(vec: Vector) -> number {
	return self.x * vec.x + self.y * vec.y
}



struct Ramp {
	currentSpeed: number,
	maxAccel: number,
	maxDecel: number

	constructor(timeToMax: number, timeToStop: number) {
		self.currentSpeed = 0
		self.maxAccel = 1 / (50 * timeToMax)
		self.maxDecel = 1 / (50 * timeToStop)
	}
}

Ramp:ramp := func(targetSpeed: number) -> number {
	self.currentSpeed = doGrossRampStuff(self.currentSpeed, targetSpeed, self.maxAccel, self.maxDecel)
	return self.currentSpeed
}

struct PIDController {
	kp: number,
	ki: number,
	kd: number,
	integral: number,
	previousError: number?,
	previousOutput: number?,
	previousTime: number,
	dt: number,
	shouldRunIntegral: boolean

	constructor(p: number, i: number, d: number) {
		self.kp = p || 0
		self.ki = i || 0
		self.kd = d || 0
		self.integral = 0
		self.previousError = nil
		self.previousOutput = nil
		self.previousTime = 0
		self.dt = 0
		self.shouldRunIntegral = false
	}
}

PIDController:clear := func(time: number) {
	self.dt = 0
	self.previousTime = time
	self.integral = 0
	self.previousError = nil
	self.previousOutput = nil
	self.shouldRunIntegral = false
}

PIDController:pid := func(
	input: number,
	setpoint: number,
	thresh: number?,
	maxChange: number?,
	maxOutput: number?
) -> number {
	threshold := thresh || 0
	error := setpoint - input
	p := error * self.kp
	i := 0

	if self.shouldRunIntegral {
		if threshold == 0 || (input < (threshold + setpoint) && input > (setpoint - threshold)) {
			self.integral = self.integral + self.dt * error
		} else {
			self.integral = 0
		}
	} else {
		self.shouldRunIntegral = true
	}

	d: number

	if self.previousError == nil || self.dt == 0 {
		d = 0
	} else {
		d = ((error - self.previousError) / self.dt) * self.kd
	}

	self.previousError = error

	output := p + i + d

	if self.previousOutput != nil && maxChange != nil {
		output = self.previousOutput + clampMag(output - self.previousOutput, 0, maxChange / 50)
	}

	if maxOutput != nil {
		output = clampMag(output, 0, maxOutput)
	}

	self.previousOutput = output

	return output
}



print("hello, world")

struct T {}

tests : [string]func(t: T) = {}

test := func(name: string, f: func(t: T)) {
	tests[name] = f
}

reset := "\27[0m"
red := "\27[31m"
green := "\27[32m"
blue := "\27[94m"


T:assertEqual := func(actual: number, expected: number, message: string) {
	message = message || ("expected " .. tostring(expected) .. ", but got " .. tostring(actual))
	assert(math.abs(actual - expected) < 0.00001, message)
}

test("Vector tests", func(t: T) {
	t:assertEqual(Vector:new(3, 4):length(), 5, "Vector:length()")
	t:assertEqual(Vector:new(3, 4):normalized().x, 0.6, "Vector:normalized().x")
	t:assertEqual(Vector:new(3, 4):normalized().y, 0.8, "Vector:normalized().y")
	actual := Vector:new(1, 2):rotate(math.pi / 2)
	t:assertEqual(actual.x,-2, "Vector:rotate().x")
	t:assertEqual(actual.y, 1, "Vector:rotate().y")
})

test("getTrapezoidSpeed", func(t: T) {
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, -1), 0.2)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 0), 0.2)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 0.5), 0.5)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 1), 0.8)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 1.5), 0.8)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 2), 0.8)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 3), 0.8)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 4), 0.6)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 5), 0.4)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 5, 1, 2, 6), 0.4)

		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 1, 2, -1), 0.2)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 1, 2, 0), 0.2)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 1, 2, 0.5), 0.5)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 1, 2, 1), 0.8)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 1, 2, 2), 0.6)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 1, 2, 3), 0.4)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 1, 2, 4), 0.4)

		// ramp up/down distances are greater than the total distance
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 2, 2, -1), 0.2)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 2, 2, 0), 0.2)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 2, 2, 1.5), 0.3)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 2, 2, 3), 0.4)
		t:assertEqual(getTrapezoidSpeed(0.2, 0.8, 0.4, 3, 2, 2, 4), 0.4)
})

test("doGrossRampStuff", func(t: T) {
		// positive speed
		t:assertEqual(doGrossRampStuff(0.5, 1, 0.2, 0.1), 0.7, "should accelerate by 0.2")
		t:assertEqual(doGrossRampStuff(0.5, 0.1, 0.2, 0.1), 0.4, "should decelerate by 0.1")
		t:assertEqual(doGrossRampStuff(0.5, 0, 0.2, 0.1), 0.4, "should decelerate by 0.1")
		t:assertEqual(doGrossRampStuff(0.5, -1, 0.2, 0.1), 0.4, "should decelerate by 0.1")
		t:assertEqual(
			doGrossRampStuff(0.5, 0.5, 0.2, 0.1), 0.5,
			"speed should not change when current and target are equal"
		)

		// negative speed
		t:assertEqual(doGrossRampStuff(-0.5, 1, 0.2, 0.1), -0.4, "should decelerate by 0.1")
		t:assertEqual(doGrossRampStuff(-0.5, 0, 0.2, 0.1), -0.4, "should decelerate by 0.1")
		t:assertEqual(doGrossRampStuff(-0.5, -0.1, 0.2, 0.1), -0.4, "should decelerate by 0.1")
		t:assertEqual(doGrossRampStuff(-0.5, -1, 0.2, 0.1), -0.7, "should accelerate by 0.2")
		t:assertEqual(
			doGrossRampStuff(-0.5, -0.5, 0.2, 0.1), -0.5,
			"speed should not change when current and target are equal"
		)

		// zero
		t:assertEqual(doGrossRampStuff(0, 0, 0.2, 0.1), 0, "should go nowhere at zero")
		t:assertEqual(doGrossRampStuff(0, 1, 0.2, 0.1), 0.2, "should accelerate by 0.2 positively")
		t:assertEqual(doGrossRampStuff(0, -1, 0.2, 0.1), -0.2, "should accelerate by 0.2 negatively")

		// overshoot
		t:assertEqual(doGrossRampStuff(0.5, 0.6, 1, 0.1), 0.6, "acceleration overshot when positive")
		t:assertEqual(doGrossRampStuff(-0.5, -0.6, 1, 0.1), -0.6, "acceleration overshot when negative")
		t:assertEqual(doGrossRampStuff(0.5, -0.1, 0.1, 1), -0.1, "deceleration overshot when positive")
		t:assertEqual(doGrossRampStuff(-0.5, 0.1, 0.1, 1), 0.1, "deceleration overshot when negative")
})

test("ramp", func(t: T) {
		// five ticks to max, ten ticks to stop
		ramp := Ramp:new(0.1, 0.2)

		// accelerate (positively)
		t:assertEqual(ramp:ramp(0.9), 0.2)
		t:assertEqual(ramp:ramp(0.9), 0.4)
		t:assertEqual(ramp:ramp(1.1), 0.6)
		t:assertEqual(ramp:ramp(1.1), 0.8)
		t:assertEqual(ramp:ramp(1), 1.0)
		t:assertEqual(ramp:ramp(1), 1.0)

		// decelerate (while positive)
		t:assertEqual(ramp:ramp(0.1), 0.9)
		t:assertEqual(ramp:ramp(0.1), 0.8)
		t:assertEqual(ramp:ramp(0), 0.7)
		t:assertEqual(ramp:ramp(0), 0.6)
		t:assertEqual(ramp:ramp(-0.1), 0.5)
		t:assertEqual(ramp:ramp(-0.1), 0.4)
		t:assertEqual(ramp:ramp(-1), 0.3)
		t:assertEqual(ramp:ramp(-1), 0.2)
		t:assertEqual(ramp:ramp(-1), 0.1)
		t:assertEqual(ramp:ramp(0), 0.0)
		t:assertEqual(ramp:ramp(0), 0.0)

		// accelerate (negatively)
		t:assertEqual(ramp:ramp(-0.9), -0.2)
		t:assertEqual(ramp:ramp(-0.9), -0.4)
		t:assertEqual(ramp:ramp(-1.1), -0.6)
		t:assertEqual(ramp:ramp(-1.1), -0.8)
		t:assertEqual(ramp:ramp(-1), -1.0)
		t:assertEqual(ramp:ramp(-1), -1.0)

		// decelerate (while negative)
		t:assertEqual(ramp:ramp(-0.1), -0.9)
		t:assertEqual(ramp:ramp(-0.1), -0.8)
		t:assertEqual(ramp:ramp(0), -0.7)
		t:assertEqual(ramp:ramp(0), -0.6)
		t:assertEqual(ramp:ramp(0.1), -0.5)
		t:assertEqual(ramp:ramp(0.1), -0.4)
		t:assertEqual(ramp:ramp(1), -0.3)
		t:assertEqual(ramp:ramp(1), -0.2)
		t:assertEqual(ramp:ramp(1), -0.1)
		t:assertEqual(ramp:ramp(0), 0.0)
		t:assertEqual(ramp:ramp(0), 0.0)
})

// -----------------------

for name, test in tests {
	result := blue .. name .. ": " .. reset
	ok, err := pcall(func() { test(T) })
	if ok {
		result = result .. green .. "ok, computer"
	} else {
		result = result .. red .. "test failed"
		result = result .. "\n" .. err
	}

	result = result .. reset

	print(result)
}